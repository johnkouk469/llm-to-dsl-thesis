[general]
model = "TheBloke/CodeLlama-7B-Instruct-GGUF/codellama-7b-instruct.Q4_K_S.gguf:2"
temperature = 0

[prompts]
instruction_prompt = """
Generate an smauto model for the described automation
"""
role_prompt = """
You are a highly skilled programmer.
You write smauto code for home automations.
You only output code.
"""

dsl_description = """
SmAuto is a Domain Specific Language (DSL) used to program complex automation scenarios, for connected IoT devices in smart environments.
An SmAuto model is composed of one or more brokers, zero or more entities and zero or more automations.
An SmAuto model contains information about the various devices in the smart enviroment (that are modeled as entities), the way they communicate and the automation tasks.
"""

entities = """
1. Define Your Entities:
    - Each entity represents a smart device.
    - Assign a unique name to each entity.
    - Specify a message broker for the entity to connect to.
    - Define a topic for sending and receiving messages.
    - List the attributes that describe the entity’s data.
2. Structure Entity Attributes:
    - Attributes determine the data structure and type for messages.
    - Supported attribute types include int, float, bool, str, time, list, and dict.
3. Entity Syntax:
    - Use the following syntax to define entities:
>>>>>
Entity <name>
    type: <sensor/actuator/hybrid>
    topic: "<topic>"
    broker: <broker_name>
    attributes:
        - <attribute_name>: <data_type>
    [description: "<description>"]
    [freq: <frequency>]
end
<<<<<
    - Replace / with . in topics (e.g., bedroom/aircondition to bedroom.aircondition).
4. Distinguish Between Sensors and Actuators:
    - Sensors (type: sensor) are data producers with an additional freq property to set the data publishing frequency.
    - Actuators (type: actuator) are data consumers.
5. Multi-Broker Communication:
    - Each entity can reference a different broker, allowing for multi-broker architectures.
6. Value Generation for Virtual Entities:
    - Optionally define a Value Generator and Noise Generator for each sensor attribute:
>>>>>
- <attribute_name>: <data_type> -> <ValueGenerator> with noise <NoiseGenerator>
<<<<<
    - Utilize supported value generators like constant, linear, saw, gaussian, replay, and replayFile.
    - Use noise generators like uniform and gaussian.
"""

brokers = """
1. Understand the Broker’s Role:
    - The broker serves as the central communication layer.
    - Each device communicates through a unique topic, acting as its mailbox.
2. Choose the Protocol:
Decide on the protocol your broker will support: MQTT, AMQP, or Redis.
3. Define the Broker:
    - Use the following syntax to define a broker:
>>>>>
Broker<Protocol_Type> broker_name
    host: "host_address"
    port: port_number
    auth:
        username: "username"
        password: "password"
    [vhost: "vhost_parameter"]
    [topicExchange: "exchange_parameter"]
    [rpcExchange: "exchange_parameter"]
    [db: database_number]
end
<<<<<
    - Replace Protocol_Type with MQTT, AMQP, or Redis.
    - Fill in the broker_name, host_address, port_number, username, and password.
4. Configure the Broker:
    - host: Specify the IP address or hostname of the broker.
    - port: Enter the port number for the broker.
    - auth: Provide authentication credentials (username and password).
    - vhost (Optional for AMQP): Define the virtual host parameter.
    - topicExchange (Optional for AMQP): Specify the exchange parameter for topics.
    - rpcExchange (Future support for AMQP): Indicate the exchange parameter for RPC.
    - db (Optional for Redis): State the database number.
"""

automations = """
1. Define Automations:
    - Automations are sets of actions executed when specific conditions are met.
    - These actions are directed towards entities, which are your smart devices.
2. Write the Automation Syntax:
    - Use the following structure to define an automation:
>>>>>
Automation <automation_name>
    condition: <logical_expression>
    enabled: <true/false>
    continuous: <true/false>
    actions:
        - <entity.property>: <desired_value>
    [checkOnce: <true/false>]
    [after: <dependent_automations>]
    [starts: <subsequent_automations>]
    [stops: <other_automations>]
end
<<<<<
    - Replace placeholders with actual values and conditions for your automation.
3. Set Conditions:
    - The condition field should contain logical expressions that, when true, trigger the automation.
4. Enable or Disable Automations:
    - The enabled field dictates whether the automation is active (true) or inactive (false).
5. Determine Continuity:
    - The continuous field decides if the automation should stay active after running (true) or not (false).
6. Configure Actions:
    - Under actions, list the operations to be performed on the entities when the conditions are met.
7. Configure Optional Settings:
    - checkOnce: If set to true, the automation will check the condition once and exit.
    - after: List any automations that must finish before this one starts.
    - starts: Specify which automations to start after this one ends.
    - stops: Indicate which automations to stop after this one ends.
"""

conditions = """
1. Understand Conditions:
    - Conditions in this context work similarly to those in programming languages like Python, Java, C++, or JavaScript.
    - Use entity attributes as variables within conditions by referencing them with their Fully-Qualified Name (FQN) using dot notation (entity_name.attribute_name).
2. Define Entities:
    - Define entities with their attributes, types, topics, and brokers. For example:
>>>>>
Entity <entity_name>
    type: <sensor/actuator>
    topic: "<topic_name>"
    broker: <broker_name>
    freq: <frequency>
    attributes:
        - <attribute_name>: <data_type>
end
<<<<<
3. Write Conditions:
    - Format conditions using logical operators (AND, OR, NOT, etc.) and parentheses to group them correctly.
    - For complex conditions, ensure proper nesting with parentheses, like ((condition_1) AND (condition_2)) AND (condition_3).
4. Use Lists and Dictionaries:
    - The language supports lists and dictionaries, but currently, you can only compare entire lists or dictionaries, not their individual elements.
5. Apply Operators:
    - Utilize various operators for strings, numbers, logic, booleans, lists, and dictionaries as needed.
6. Implement Built-in Functions:
    - Use built-in functions like mean, std, var, min, and max to process attribute values within conditions.
7. Compose Automations:
    - Create automations by defining conditions and the actions to be taken when those conditions are met. For example:
>>>>>
Automation <automation_name>
    condition:
        (entity_1.attribute > value) AND
        (entity_2.attribute > value)
    actions:
        - entity_3.attribute: new_value
        - entity_4.attribute: new_value
end
<<<<<
"""

actions = """
1. Identify Actuators:
    - Determine which devices in your setup are actuators (e.g., air conditioners, lights, speakers).
2. Understand Action Messages:
    - Actions are messages that command actuators to perform a specific operation.
3. Format Actions:
    - Write each action on a single line using the format:
>>>>>
entity_name.attribute_name: value
<<<<<
    - Replace entity_name with the name of your actuator, attribute_name with the property you want to control, and value with the desired setting.
4. Determine Value Types:
    - The value can be of various data types, including:
        - string (e.g., “on”, “off”)
        - number (e.g., 25, 75)
        - boolean (e.g., true, false)
        - list (e.g., [1, 2, 3])
        - dictionary (e.g., {“key”: “value”})
"""

rtmonitor = """
1. Understand RTMonitor:
    - RTMonitor sets up monitoring for the SmAuto runtime environment.
    - It works alongside an executor that manages compiled automations and collects runtime data.
2. Define RTMonitor:
    - Use the following syntax to define RTMonitor in your program:
>>>>>
RTMonitor
    broker: <broker_name>
    namespace: "<namespace>"
    eventTopic: "<event_topic>"
    logsTopic: "<logs_topic>"
end
<<<<<
    - Replace <broker_name> with the name of the broker you’re referencing.
    - Set <namespace> to a prefix used for constructing URIs.
    - Assign <event_topic> to the topic where events will be published.
    - Designate <logs_topic> to the topic for sending logs.
3. Configure Properties:
    - broker: Link this to your previously defined broker.
    - namespace: Define a unique namespace for your setup.
    - eventTopic: Specify the topic for event messages.
    - logsTopic: Indicate the topic for log messages.
"""

constraints = """
You should comply to the following constrants:
    - Value and Noise Generators can only be applied to Entities of type "sensor" or 
"robot".
    - Actions can only refer Attributes of "actuator" and "robot" Entities.
    - Only "actuator" and "robot" Attributes can have default values.
    - The freq property can only be set only for sensor and robot Entities.
"""

example_input = """
Set the aircondition in my bedroom to 25 degrees in cool mode, when it is already on and the temperature is higher than 32 degrees.
"""

example_output = """
Broker<MQTT> home_broker
    host: "localhost"
    port: 1883
    auth:
        username: ""
        password: ""
end

Entity weather_station
    type: sensor
    topic: "porch.weather_station"
    broker: home_broker
    attributes:
        - temperature: float
        - humidity: int
end

Entity aircondition
    type: actuator
    topic: "bedroom.aircondition"
    broker: home_broker
    attributes:
        - temperature: float
        - mode: str
        - on: bool
end

Automation start_aircondition
    condition:
        (weather_station.temperature > 32) AND
        (aircondition.on is true)
    enabled: true
    continuous: false
    actions:
        - aircondition.temperature:  25.0
        - aircondition.mode:  "cool"
        - aircondition.on:  true
end
"""